with (import <nixpkgs/lib>);
rec {
	abs = x: if x < 0 then (-x) else x;
	addTuples = a: b: zipListsWith (x: y: x + y) a b;
	charAt = i: s: substring i 1 s;
	charsToString = l: concatStringsSep "" l;
	contains = x: l: any (i: i == x) l;
	dropWhile = f: l: if f (head l) then dropWhile f (forward l) else l;
	empty = l: length l == 0;
	findIndex = e: l: if empty l then infty else if head l == e then 0 else 1 + findIndex e (forward l);
	forward = drop 1;
	gridAt = g: x: y: elemAt (elemAt g y) x;
	gridSetAt = g: x: y: c: setAt g y (setAt (elemAt g y) x c);
	infty = 1073741823;
	iter = f: n: if n == 0 then x: x else x: (iter f (n - 1)) (f x);
	min = l: head (sortasc l);
	max = l: head (sortdec l);
	product = foldl' (l: n: l * n) 1;
	read = i: trimLines (splitString "\n" i);
	setAt = l: i: x: (take i l) ++ [x] ++ (drop (i + 1) l);
	shiftr = l: [(head (reverseList l))] ++ (reverseList (forward (reverseList l)));
	sortasc = sort (a: b: a < b);
	sortdec = sort (a: b: a > b);
	subTuples = a: b: zipListsWith (x: y: x - y) a b;
	suffixFrom = i: s: substring i (stringLength s) s;
	sum = foldl' (l: n: l + n) 0;
	takeWhile = f: l: if empty l then [] else (if f (head l) then [(head l)] ++ takeWhile f (forward l) else []);
	transpose = l: [(map head l)] ++ (if length (head l) > 1 then transpose (map (l: forward l) l) else []);
	trimLines = l: filter (s: stringLength s > 0) l;
}
